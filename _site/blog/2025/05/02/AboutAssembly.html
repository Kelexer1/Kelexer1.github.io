<!DOCTYPE html>
<html>
<style>
::-webkit-scrollbar {
    display: none;
}

html {
    scrollbar-width: none;
}

body {
    -ms-overflow-style: none;
}
</style>
<head>
    <title>About Assembly</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="A centralized hub for all things Kelexer">
    <meta name="keywords" content="Kelexer, Portfolio, Blog, Bio, Biography, Hub">
    <meta name="author" content="Kelexer">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
</head>
    <main>
        <header>
            <!DOCTYPE html>
<html lang="en">
    <style>
        .NavBar {
            display: flex;
            align-items: center;
            padding: 0.5rem;
            margin: 0px;
            justify-content: space-between;
            background-color: #20232e;
        }
        .NavBar ul li a {
            color: #EDE8F5;
            text-decoration: none;
            transition: transform 0.5s ease;
            display: inline-block;
        }
        .NavBar ul li a:hover {
            color: #ADBBDA;
            transform: scale(1.2);
            transform-origin: center;
        }
        .NavBar ul{
            font-family: 'Poppins', sans-serif;
            list-style-type: none;
            display: flex;
            gap: 3rem;
            padding-right: 5%;
        }
        .NavBar img {
            width: 4rem;
            margin: 0;
        }
        body {
        margin: 0;
        }
        #Logo {
            transition: transform 0.3s ease-out
        }
        #Logo:hover {
            transform: rotate(360deg);
        }

        .hamburger {
            display: none;
            font-size: 2rem;
            color: #EDE8F5;
        }

        @media (max-width: 768px) {
            .NavBar ul {
                display: none;
                flex-direction: column;
                gap: 1rem;
                padding-right: 0;
                width: 70vw;
                background-color: #20232e;
                position: absolute;
                top: 4rem;
                left: 50%;
                transform: translate(-50%, 15px);
                z-index: 1000;
                align-items: center;
                border-radius: 7px;
            }

            .NavBar ul li:first-child {
                margin-top: 2rem;
            }

            .NavBar ul li:last-child {
                margin-bottom: 2rem;
            }

            #navmenu {
                padding: 0;
                align-self: center;
            }

            .NavBar ul.show {
                display: flex;
            }

            .hamburger {
                display: block;
                cursor: pointer;
            }

        }

    </style>
    <body>
        <div class="NavBar">
            <img src="/Resources/KelexerLogo.svg" alt="Logo" id="Logo"/>
            <div class="hamburger" onclick="toggleMenu()">☰</div>
            <ul id="navmenu">
                <li><a href="/">Home</a></li>
                <li><a href="/blog">Blog</a></li>
                <li><a href="/aboutme">About Me</a></li>
            </ul>
        </div>
        <script>
            function toggleMenu() {
                var menu = document.getElementById('navmenu');
                menu.classList.toggle('show');
            }
        </script>
    </body>
    </html>
        </header>
        <body>
            <html>
    <head>
        <link rel="stylesheet" href="/css/post.css">
        <link rel="stylesheet" href="/css/syntax.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/cascadia-code@latest/index.css">
        <script src="/js/post.js"></script>
    </head>
    <body>
        <div id="progressContainer">
            <div id="progressBar"></div>
        </div>
        <section id="content">
            <div id="info">
                <div id="titles">
                    <h1>About Assembly</h1>
                    <h2>My thoughts after self-teaching assembly and using it for cybersecurity</h2>
                </div>
                <h3>Posted on May 02, 2025</h3>
            </div>
            <hr>
            <article>
                <p>I’ve spent the past 2 weeks self teaching NASM x86 Assembly (primarily on Linux), and I wanted to share my thoughts and experiences from what I’ve learned, and how I plan to apply and further my skills.</p>

<p>Programming languages can be ranked on a sort of scale, from high level to low level. The “higher” level a language is, the closer the syntax to human readable language. Take python for example, where printing a message to the console is as easy as the one line solution:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
</code></pre></div></div>

<p>Of course there is a lot more going on behind the scenes automatically, which is why high level languages like Python are so easy to learn and write in compared to other languages. Now this automation usually comes at the cost of speed and bloat, where code may not be fully optimized due to the automated optimizations and extra features of the language that your program may not require. That’s where lower level languages, like C, come into play. When you write code in C, you are expected to manage a lot more with your code than simply the syntax. With C, you are expected to manually manage your computer memory, and forgo commonly used features, like object-oriented programming. This however, comes at the benefit of <em>much</em> faster runtimes compared to languages like Python (even if you account for the fact that Python is interpreted, not compiled). Additionally, lower level languages allow you to work much closer to the hardware of the computer, such as the memory, as previously mentioned. This can allow for much more optimizations in your code, as well as accomplishing tasks that are just not realistic in higher level languages (think device drivers, etc.). For comparison, here is the same code as above, but written in C instead:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello, world!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, notice that I haven’t mentioned where assembly fits into all of this, and I’m getting to that. I mentioned how python is interpreted, not compiled, which basically means the computer reads it line by line and works with the code that way. Compiled languages convert your code into assembly (CPU instructions), which the computer then works with. This is how compiled languages run so fast. Of course, there is more nuance to how this stuff works, but it is a very broad and complicated topic (I also have never explicitly learned about it, yet), though this is a high level explanation. Now, here is the same code written in NASM x86 Assembly (Linux), which would then need to be manually assembled and linked to be ran:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">section</span> <span class="nv">.data</span>
	<span class="nf">output</span> <span class="nv">DB</span> <span class="s">"Hello, world!"</span><span class="p">,</span> <span class="mi">10</span>

<span class="nf">section</span> <span class="nv">.text</span>
	<span class="nf">global</span> <span class="nv">_start</span>

<span class="nl">_start:</span>
	<span class="nf">MOV</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>
	<span class="nf">MOV</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>
	<span class="nf">MOV</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nv">output</span>
	<span class="nf">MOV</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">14</span>
	<span class="nf">INT</span> <span class="mh">80h</span>

	<span class="nf">MOV</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>
	<span class="nf">MOV</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>
	<span class="nf">INT</span> <span class="mh">80h</span>
</code></pre></div></div>
<p>As you can see, assembly appears to be maybe just a <em>little</em> bit harder to read…</p>

<p>Assembly used to the the language that hid under my bed at night, and that was mostly reinforced by things like YouTube Shorts and Instagram Reels, where they portray assembly as the boss battle of programming languages. And don’t get me wrong, I still think it is, but I can now say that the difficulty is <em>not</em> as high as media claims it to be.</p>

<p>I originally wanted to pick up assembly for a few reasons. Namely, I wanted to further my cybersecurity skills by getting started on reverse engineering programs. When you run a file like a <code class="language-plaintext highlighter-rouge">.exe</code> on your computer, you are actually executing a binary file of machine code, which can be decompiled to assembly using a tool known as a decompiler. Now, while you can continue to go “higher” into even more readable languages, the output will become increasingly nonsense, as there is <em>many</em> ways to make code with the same output, so the decompiler has no way of determining the “correct” output, so it will try to guess, which doesn’t always work out well. That’s why assembly is preferred for reverse engineering. By the end of this initial learning phase, I wanted to take part in a “crack me” to see if I could actually read real programs decompiled into assembly and reverse engineer / modify them to create desirable results, in this case being able to gain access to a software without a licence key. Don’t worry, crack me’s are mock software’s designed to be reverse engineered, so there is nothing illegal about it.</p>

<p>Secondly, I wanted to actually be able to read and write in assembly using documentation, and not AI like ChatGPT. Of course, in the process of learning it, I would memorize a lot of commonly used instructions, but learning how to read detailed documentation is a beneficial skill independent of programming language. I would also be able to demonstrate this by reverse engineering a program.</p>

<p>I mainly learned the language using the following playlist, which was super helpful and easy to follow along, although I was on my own when figuring out how to set up a Linux VM and install all the required packages.</p>
<iframe width="819.5" height="461" src="https://www.youtube.com/embed/yBO-EJoVDo0?list=PL2EF13wm-hWCoj6tUBGUmrkJmH1972dBB" title="Foundations of Assembly Programming - Binary Numbers" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>Once I completed all the videos in the playlist that dealt with assembly programming (omitting the operating system content in the second half) I felt I had a pretty solid understanding of the material, and I was already able to code basic programs with minimal additional learning resources. Therefore, I made my first attempt at using Ghidra to reverse engineer a crack me that I got from <a href="https://crackmes.one/crackme/67fd376f8f555589f3530b9d">https://www.crackmes.one</a>.</p>
<h2 id="crack-me-write-up">Crack Me Write Up</h2>

<p>The first step was to run the program itself and try to get a high understanding of how the program worked. Entering an invalid key gave a specific string error message, which is crucial for reverse engineering. If I could find the string reference in the decompiled assembly, I could find what parts of the code are causing the message to be displayed, then backtrack to find the code for the block that determines whether the key is valid.</p>

<p><img src="/Resources/BlogResources/2025-05-02-AboutAssembly/InvalidKey.jpg" alt="Image of invalid key result" /></p>

<p>Then, we can use Ghidra to decompile the program, which will give us access to all the scary looking source code (the program itself was written in <code class="language-plaintext highlighter-rouge">C</code> or <code class="language-plaintext highlighter-rouge">C++</code>, then compiled into this). Ghidra looks complicated to use (because it is), but 99% of the features are not required to complete a basic crack me like this. Analyzing the file will format the source code into the assembly we are looking for.</p>

<p><img src="/Resources/BlogResources/2025-05-02-AboutAssembly/GhidraAnalyze.jpg" alt="Image of Ghidra analyze menu" /></p>

<p>After that, we can use the string search tool to scan the entire source code for the text “Invalid Licence”. This is helpful because, as previously mentioned, we can find what part of the code is telling the program to give the warning message, and change it to always accept an invalid key.</p>

<p><img src="/Resources/BlogResources/2025-05-02-AboutAssembly/GhidraString.jpg" alt="Image of Ghidra string search tool" /></p>

<p>As you can see in the image, we have located two important strings, the invalid key string, and the valid key string. It doesn’t really matter which one we follow through the code, as they should end up at roughly the same spot in the code. We will follow the invalid key string for consistency, which takes us to the following block of code:</p>

<p><img src="/Resources/BlogResources/2025-05-02-AboutAssembly/GhidraStringTrace.jpg" alt="Image of Ghidra string trace" /></p>

<p><strong>A quick note: The comment reading “Success Code” should say “Display Message Box”</strong></p>

<p>In the this image, I have highlighted important CPU instructions in yellow, and comments I have made explaining the code in blue, since Ghidra’s GUI can be overwhelming to look at. Additionally, I have traced the flow of the code for valid and invalid keys in blue and red, respectively. In general, though, this code checks if the value in register R14B (This is related to the value the user entered, but it may have been altered or have other stuff done to it before this point). If the value is equal to 0, meaning the string is empty or contains only null bytes, then the code jumps to the invalid licence prompt, which is assigned the label <code class="language-plaintext highlighter-rouge">LAB_1400017e4</code> by Ghidra (labels are segments of code with a specific title). Otherwise, it continues and goes straight to the success prompt. To make this code work in our favor, we want the code to never enter the invalid key label, since that will set the message values to be the incorrect key values. We can do this by negating the condition of the jump instruction from equals 0, to not-equals 0. When we do this, we effectively make incorrect keys correct, and correct keys incorrect. Applying this fix is as simple as modifying the second yellow-highlighted instruction to be <code class="language-plaintext highlighter-rouge">JNZ LAB_1400017e4</code> instead of <code class="language-plaintext highlighter-rouge">JZ LAB_1400017e4</code>. Now, when we enter an invalid key, it will not go into the incorrect key label, and will instead set the value of the message box to be the values that indicate a successful key, then it will jump to label <code class="language-plaintext highlighter-rouge">LAB_1400017f2</code>, which will display the message box with whatever values have been set, whether from the success or fail parts of the code. We are now left with the following assembly instructions:</p>

<p><img src="/Resources/BlogResources/2025-05-02-AboutAssembly/GhidraPatched.jpg" alt="Image of patched assembly instructions" /></p>

<p>Exporting this new program gives us an executable that is identical in every way, except its set to accept invalid license keys as valid. We can verify this by running the new program and entering a random value.</p>

<p><img src="/Resources/BlogResources/2025-05-02-AboutAssembly/GhidraFinal.jpg" alt="Image of final result" /></p>

<p>And just like that, we have cracked this mock software using the power of assembly and decomplication. Even though this is a very easy task compared to real-world applications of decompilation, I am still proud of myself for being able to do this on my own with minimal supplementary learning (except googling what <code class="language-plaintext highlighter-rouge">LEA</code> and <code class="language-plaintext highlighter-rouge">TEST</code> do, since the course I used didn’t cover them). I plan to continue to further my assembly skills along with my cybersecurity skills by delving into more advanced topics now that I have a strong foundation to build off of.</p>

<p>That’s all for now.</p>

<p>✌️,<br />Thomas</p>

            </article>
        </section>
    </body>
</html>
        </body>
    </main>
</html>